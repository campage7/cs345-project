# cs345-project
# Zero Knowledge Proof by Cameron Page & Franco Diaz

A Zero Knowledge Proof (ZKP) is a protocol where a statement can be verified as true (or not true) without revealing anything about the statement itself.

ZKPs can be used in authentication protocols to enable users to prove their identity or access rights without revealing sensitive information such as passwords or biometric data. This enhances security while maintaining user privacy.

ZKPs enable parties to prove the truth of a statement or the possession of certain information without revealing any additional information beyond the validity of the statement itself.

ZKPs can sometimes offer more efficient solutions compared to traditional cryptographic methods. For example, they can enable secure multiparty computation with lower communication and computational overhead, making them suitable for resource-constrained environments.

# ZKPs and Blockchain Networks

One particularly niche application of ZKPs is scaling Turing-complete public blockchain networks. Blockchain nodes traditionally verify the computational results of their peers by re-performing the same computation to produce a matching result. More specifically, a "block" contains a sequence of messages known as "transactions" which, when executed in order, produce a deterministic resulting state. The new state is considered valid when a majority of nodes agree on and apply the new state to their local histories.

"Rollups" are a popular scaling solution for public blockchains which aim to offload execution to a separate network, only posting the results of that execution onto the main chain. This greatly improves execution costs and speed by contrastly (1) retaining a *single* party (a "Sequencer") responsible for executing *all* user transactions and (2) therefore require a robust proof mechanism for keeping this centralized Sequencer in check and verifying all proposed state transitions. ZKPs are this robust proof mechanism, which allow another party to verify the Sequencer's valid execution *without* re-executing the transactions themselves.

# Our Project

Our project will demonstrate this creative use case of ZKPs. We will depict a simple ZK rollup system which uses a Sequencer to execute transactions and reach a proposed new state, a Prover algorithm to generate a basic ZK proof (Merkle proof) of this new state in order for a Verifier to verify the validity of the proposed state before it is updated. In this, we show how ZK proofs are used as a *lightweight* method of verifying *intense* computation of another party.

As a note, we abstract away/simplify:
- tx generation by users
- tx execution
- block hashes/batches of blocks
- a defined state transition function
- advanced Prover-Verifier algorithms (SNARKs/STARKs)

# Structure and Algorithms

Transactions and Block objects

*The smallest building blocks of the system. Transactions from users are bundled into a Block which are executed in order to produce a new state from the previous state. A Transaction is represented with a simple 3-char ID; only SWP, SND, and MNT are valid transactions. A Block contains an ordered list of its transactions and a corresponding resulting state after executing those transactions.*

ZKProof objects

*Generated by a Prover using a given hash of a proposed new state. Contains a supposedly valid path of hashes generated by the Prover which the Verifier compares against the path of hashes they personally calculate using the same state hash.*

Recursive MerkleTree structure of TreeNodes

*Dynamic data structure used for storing state hashes as new blocks are verified. Both Prover and Verifier use the MerkleTree to generate a matching path of hashes up to the root, proving a given state was executed by the Sequencer according to the state transition function.*

Sequencer algorithm

*Executes bundles (blocks) of transactions in order to produce a new state. Execution is simulated by simply concatenation transaction IDs in the order they are processed into a single resulting string. The block number is appended to the end of the resulting state string (e.g. SWPSWPSNDMNT5. The Sequencer generates a SHA-256 hash of the resulting state string, and submits this to the Prover.*

Prover and Verifier algorithms

*The Prover generates a ZKProof object (a valid hash path in the MerkleTree) from the Sequencer's state hash. It submits the proof to the Verifier, which attempts to generate a matching hash path from the Merkle Tree starting at the same state hash. If successful, the proof and the underlying execution can be considerd valid and verified. Otherwise, the proposed block is considered invalid and rejected by the Verifier.*
